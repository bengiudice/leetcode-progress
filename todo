heap & priority queue
 keywords: kth largest closest scheduler frequent max min
 heapify O(n)
 add del O(logn)
 use multiple
 pair (_,_)
 can be slightly more efficient than sorting if you dont end up visiting entire array

hashmap

two pointers
 calculate maxLeft and maxRight grid via scan
 pre-calculate useful intermediataries as a grid via scaning
 can reduce memory to O 1 by replacing calculated-grid with variables and pointers
 shift minimum pointer

python
 sort(key=lambda i: ...)

sliding window
 counts hashmap
 pointers for window edges
 have counts and need counts
 grow and shrink window
 O k(n-k)
 monotonically inc/dec deque as window

greedy
 kadanes alg (currMax, globalMax)
 simultaneous min/max kadanes for circular array. min = sum - max
 initialise globals with an element of the array
 bfs with global to eliminate repeated work
 sliding window (l,r pointer)
 sort
 dfs + cache
 bruteforce decision tree + cache
 greedy can be better than DP

intervals
 numberline
 covering: >=
 sort left point?
 
strings
 * appends multiple copies

math & geometry
 mod %
 integer division (round down) //

sort
 quicksort
 mergesort
 bucketsort
 topological sort

search
 quickselect Oav(n) O(n2)
 left/right bias binary search

zero
 neither strictly positive nor strictly negative
 non-negative
 non-positive
 even

longest increasing subsequence
 lis
 maintain relative order
 can skip elements
 decision tree
 dynamic programming

linked list
 dummy head node
 mergeSortedLists via mergesort O klogn
 mergeLists helper fn



constants
 inf => float("inf")


dynamic programming
 keywords: minimum ways maximum
 no: create each combination
 overlapping subproblems
 bottom up
 dp array
 brute force recursion decision tree -> cache/memoise -> optimise by DP
 cache/memoise is top down
 1D -> array -> maybe just a few values
 2D -> matrix
 recurrance relation
 parameters for subproblem
 size of cache
 key for cache
 make the grid/row and solve from one end
 recognise that a more efficient math solution likely exists
 solve smaller first then move towards larger subproblems
 2D
  bruteforce recursion dfs(row,  col)
  hashmap grid as cache
  bottom up
  likely only need one row in memory
  outside layer row/col

monotonic in/decreasing stack
 
pre/postfix array

divide and conquor
 independent subproblems

in-place
 swap
 store multiple in one pointer

graph
 dfs
 bfs O n2 queue
 visit hashset
 ROWS, COLS = len(grid), len(grid[0])
 O E+V
 reuse other ds as visit
 out-of-bounds helper fn
 diagonal? (manhattan-distance)
 direction array
 shortest path: weights=dijstras otherwise=bfs
 bfs supports multiple sources/destinations
 brute force O E^V
 dijstras heap greedy ElogV^2=E2logV=ElogV
 adjacency list hashmap(list)

top/least K
 heap
 quickselect

common strings
 map
 trie

backtracking
 keywords: subsets combinations permutations partition bruteforce 
 decision tree
 bitmask
 backtrack when decision incorrect
 pruning
 O decisions ^ input/height
 counts remaining hashmap
 can lead to DP

combinations
 loose bound: O kn^k
 tight bound: O kn!/(n-k)!k!
 no-duplicates

permutations
 order matters
 spots choices

subsets

partitions

subsequences

stuck?
 sort?

tree set/map
monotonic inc/dec stack
min/max heap
priority queue
iterative/recursive DFS/BFS
KMC
invert tree
reverse linked list (in-place)
union find
pre/post order tree traversal
sort into and modify BST
generate all trees
combinations
permutations
subsets
subsequences
anagrams
palindromes
binary math
decision tree
fast slow linked list pointer

