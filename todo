heap & priority queue
 keywords: kth largest closest scheduler frequent max min
 heapify O(n)
 add del O(logn)
 use multiple
 pair (_,_)
hashmap
sort
 quicksort
 mergesort
 bucketsort
 topological sort
search
 quickselect Oav(n) O(n2)
 left/right bias binary search
dynamic programming
 no: create each combination
 overlapping subproblems
divide and conquor
 independent subproblems

in-place
 swap
 store multiple in one pointer

graph
 dfs
 bfs O n2 queue
 visit hashset
 ROWS, COLS = len(grid), len(grid[0])
 O E+V
 reuse other ds as visit
 out-of-bounds helper fn
 diagonal? (manhattan-distance)
 direction array
 shortest path: weights=dijstras otherwise=bfs
 bfs supports multiple sources/destinations

top/least K
 heap
 quickselect

common strings
 map
 trie

backtracking
 keywords: subsets combinations permutations partition bruteforce 
 decision tree
 bitmask
 backtrack when decision incorrect
 pruning
 O decisions ^ input/height
 counts remaining hashmap
 can lead to DP
combinations
 loose bound: O kn^k
 tight bound: O kn!/(n-k)!k!
 no-duplicates
permutations
 order matters
 spots choices
subsets
partitions
subsequences


stuck?
 sort?
tree set/map
monotonic inc/dec stack
min/max heap
priority queue
iterative/recursive DFS/BFS
KMC
invert tree
reverse linked list (in-place)
union find
pre/post order tree traversal
sort into and modify BST
generate all trees
combinations
permutations
subsets
subsequences
anagrams
palindromes
binary math
decision tree
fast slow linked list pointer

