heap & priority queue
 keywords: kth largest closest scheduler frequent max min
 heapify O(n)
 add del O(logn)
 use multiple
 pair (_,_)
hashmap
sort
 quicksort
 mergesort
 bucketsort
 topological sort
search
 quickselect Oav(n) O(n2)
 left/right bias binary search

zero
 neither strictly positive nor strictly negative
 non-negative
 non-positive
 even

longest increasing subsequence
 lis
 maintain relative order
 can skip elements
 decision tree
 dynamic programming


dynamic programming
 keywords: minimum ways maximum
 no: create each combination
 overlapping subproblems
 bottom up
 dp array
 brute force recursion decision tree -> cache/memoise -> optimise by DP
 cache/memoise is top down
 1D -> array -> maybe just a few values
 2D -> matrix
 recurrance relation
 parameters for subproblem
 size of cache
 make the grid/row and solve from one end
 recognise that a more efficient math solution likely exists
 solve smaller first then move towards larger subproblems


monotonic in/decreasing stack
 
pre/postfix array

divide and conquor
 independent subproblems

in-place
 swap
 store multiple in one pointer

graph
 dfs
 bfs O n2 queue
 visit hashset
 ROWS, COLS = len(grid), len(grid[0])
 O E+V
 reuse other ds as visit
 out-of-bounds helper fn
 diagonal? (manhattan-distance)
 direction array
 shortest path: weights=dijstras otherwise=bfs
 bfs supports multiple sources/destinations
 brute force O E^V
 dijstras heap greedy ElogV^2=E2logV=ElogV
 adjacency list hashmap(list)

top/least K
 heap
 quickselect

common strings
 map
 trie

backtracking
 keywords: subsets combinations permutations partition bruteforce 
 decision tree
 bitmask
 backtrack when decision incorrect
 pruning
 O decisions ^ input/height
 counts remaining hashmap
 can lead to DP
combinations
 loose bound: O kn^k
 tight bound: O kn!/(n-k)!k!
 no-duplicates
permutations
 order matters
 spots choices
subsets
partitions
subsequences


stuck?
 sort?
tree set/map
monotonic inc/dec stack
min/max heap
priority queue
iterative/recursive DFS/BFS
KMC
invert tree
reverse linked list (in-place)
union find
pre/post order tree traversal
sort into and modify BST
generate all trees
combinations
permutations
subsets
subsequences
anagrams
palindromes
binary math
decision tree
fast slow linked list pointer

